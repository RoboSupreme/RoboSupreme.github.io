// Set transition for smooth color change
this.element.style.transition = 'background-color 6s linear';

        // Set lifespan
        this.lifespan = 6000; // 6 seconds
        this.birthTime = Date.now();

// Flag to indicate if the bubble should shrink
this.shrink = false;
this.shrinkStartTime = null;
@@ -195,8 +191,8 @@

if (shrinkRatio > 0) {
this.size = this.originalSize * shrinkRatio;
            this.vx *= shrinkRatio; // Slow down the bubble's speed as it shrinks
            this.vy *= shrinkRatio;
            this.vx *= 0.99; // Slow down the bubble's speed as it shrinks
            this.vy *= 0.99;
this.element.style.width = `${this.size}px`;
this.element.style.height = `${this.size}px`;
this.element.style.opacity = `${shrinkRatio * 0.8}`; // Fade out as it shrinks
@@ -205,110 +201,105 @@
}
}

        // Check lifespan
        if (Date.now() - this.birthTime > this.lifespan && !this.shrink) {
          this.destroy();
        }

// Handle bubble-bubble collisions
bubbles.forEach(other => {
if (other !== this && this.isCollidingWith(other)) {
this.resolveCollision(other);
}
});
}

isCollidingWith(other) {
const dx = (this.x + this.size / 2) - (other.x + other.size / 2);
const dy = (this.y + this.size / 2) - (other.y + other.size / 2);
const distance = Math.sqrt(dx * dx + dy * dy);
return distance < (this.size / 2 + other.size / 2);
}

resolveCollision(other) {
// Simple elastic collision response

// Calculate the normal vector
const dx = (other.x + other.size / 2) - (this.x + this.size / 2);
const dy = (other.y + other.size / 2) - (this.y + this.size / 2);
const distance = Math.sqrt(dx * dx + dy * dy);

if (distance === 0) return; // Prevent division by zero

const nx = dx / distance;
const ny = dy / distance;

// Calculate relative velocity
const dvx = this.vx - other.vx;
const dvy = this.vy - other.vy;

// Calculate velocity along the normal
const velAlongNormal = dvx * nx + dvy * ny;

// Do not resolve if velocities are separating
if (velAlongNormal > 0) return;

// Coefficient of restitution (elastic collision)
const restitution = 1;

// Calculate impulse scalar
const impulse = -(1 + restitution) * velAlongNormal / 2; // Assuming equal mass

// Apply impulse to both bubbles
this.vx += impulse * nx;
this.vy += impulse * ny;
other.vx -= impulse * nx;
other.vy -= impulse * ny;

// Prevent overlapping
const overlap = 0.5 * (this.size / 2 + other.size / 2 - distance + 1);
this.x -= overlap * nx;
this.y -= overlap * ny;
other.x += overlap * nx;
other.y += overlap * ny;

this.element.style.left = `${this.x}px`;
this.element.style.top = `${this.y}px`;
other.element.style.left = `${other.x}px`;
other.element.style.top = `${other.y}px`;
}

destroy() {
cancelAnimationFrame(this.animation);
this.element.remove();
const index = bubbles.indexOf(this);
if (index > -1) {
bubbles.splice(index, 1);
}
}
}

// Initialize bubbles
function initBubbles() {
for (let i = 0; i < bubbleCount; i++) {
bubbles.push(new Bubble());
}
}

// Handle window resize
window.addEventListener('resize', () => {
bubbles.forEach(bubble => {
bubble.x = Math.max(0, Math.min(bubble.x, window.innerWidth - bubble.size));
bubble.y = Math.max(0, Math.min(bubble.y, window.innerHeight - bubble.size));
bubble.element.style.left = `${bubble.x}px`;
bubble.element.style.top = `${bubble.y}px`;
});
});

// Periodically add new bubbles to maintain bubble count
setInterval(() => {
if (bubbles.length < bubbleCount) {
bubbles.push(new Bubble());
}
}, 2000);

// Initialize on page load
initBubbles();
</script>
</body>
</html>
