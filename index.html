<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Enhanced Interactive Bubble Simulation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Arial', sans-serif;
      height: 100vh;
      overflow: hidden;
      position: relative;
      /* Smooth background gradient animation */
      background: linear-gradient(135deg, #ff7e5f, #feb47b, #6a11cb, #2575fc, #ff6a00, #ee0979, #ff7e5f);
      background-size: 1400% 1400%;
      animation: gradientAnimation 60s ease infinite;
    }

    @keyframes gradientAnimation {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* Controls Panel */
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 8px;
      color: white;
      z-index: 10;
      font-size: 14px;
    }

    #controls label {
      display: block;
      margin-bottom: 8px;
    }

    #controls input[type="range"] {
      width: 200px;
    }
  </style>
</head>
<body>
  <!-- Controls Panel -->
  <div id="controls">
    <label>
      Drag: <input type="range" id="dragSlider" min="0.90" max="1.00" step="0.001" value="0.99">
      <span id="dragValue">0.990</span>
    </label>
    <label>
      Acceleration Y: <input type="range" id="accSlider" min="-0.1" max="0.1" step="0.001" value="-0.05">
      <span id="accValue">-0.050</span>
    </label>
  </div>

  <!-- Canvas Element -->
  <canvas id="bubbleCanvas"></canvas>

  <script>
    // Vector Class for 2D Vector Operations
    class Vector {
      constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
      }

      add(vec) {
        this.x += vec.x;
        this.y += vec.y;
      }

      subtract(vec) {
        this.x -= vec.x;
        this.y -= vec.y;
      }

      multiply(scalar) {
        this.x *= scalar;
        this.y *= scalar;
      }

      divide(scalar) {
        if (scalar !== 0) {
          this.x /= scalar;
          this.y /= scalar;
        }
      }

      dot(vec) {
        return this.x * vec.x + this.y * vec.y;
      }

      magnitude() {
        return Math.sqrt(this.x ** 2 + this.y ** 2);
      }

      normalize() {
        const mag = this.magnitude();
        if (mag > 0) {
          this.divide(mag);
        }
      }

      clone() {
        return new Vector(this.x, this.y);
      }
    }

    // Utility function to generate a random number within a range
    function random(min, max) {
      return Math.random() * (max - min) + min;
    }

    // Color Palette
    const colors = [
      'rgba(255, 255, 255, 0.7)',
      'rgba(0, 255, 255, 0.6)',
      'rgba(255, 0, 255, 0.5)',
      'rgba(255, 255, 0, 0.5)',
      'rgba(0, 255, 0, 0.5)',
      'rgba(255, 165, 0, 0.6)',
      'rgba(138, 43, 226, 0.6)',
      'rgba(0, 191, 255, 0.6)',
      'rgba(173, 255, 47, 0.6)',
      'rgba(255, 20, 147, 0.6)',
      'rgba(75, 0, 130, 0.6)',
      'rgba(255, 105, 180, 0.6)'
    ];

    // Canvas Setup
    const canvas = document.getElementById('bubbleCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Handle window resize
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    // Mouse Interaction
    const mouse = { x: null, y: null };
    window.addEventListener('mousemove', (event) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = event.clientX - rect.left;
      mouse.y = event.clientY - rect.top;
    });

    window.addEventListener('mouseleave', () => {
      mouse.x = null;
      mouse.y = null;
    });

    // Spatial Partitioning Grid
    const gridSize = 200; // Size of each grid cell
    const grid = {};

    function getGridKey(x, y) {
      const col = Math.floor(x / gridSize);
      const row = Math.floor(y / gridSize);
      return `${col},${row}`;
    }

    // Bubble Class
    class Bubble {
      constructor() {
        this.size = random(50, 150);
        this.radius = this.size / 2;
        this.position = new Vector(random(this.radius, canvas.width - this.radius), random(this.radius, canvas.height - this.radius));
        const speed = random(0.5, 2);
        const angle = random(0, 2 * Math.PI);
        this.velocity = new Vector(Math.cos(angle) * speed, Math.sin(angle) * speed);
        this.acceleration = new Vector(0, -0.05); // Upward acceleration (buoyancy)
        this.drag = 0.99; // Initial drag value
        this.color = colors[Math.floor(Math.random() * colors.length)];
        this.mass = this.size; // Mass proportional to size
        this.shrink = false;
        this.shrinkStartTime = null;
        this.originalSize = this.size;
        this.opacity = 0.8;
      }

      update() {
        // Apply acceleration
        this.velocity.add(this.acceleration);

        // Apply drag
        this.velocity.multiply(this.drag);

        // Update position
        this.position.add(this.velocity);

        // Handle wall collisions
        this.handleWallCollision();

        // Assign to grid
        const key = getGridKey(this.position.x, this.position.y);
        if (!grid[key]) grid[key] = [];
        grid[key].push(this);

        // Apply mouse repulsion
        this.applyMouseRepulsion();
      }

      handleWallCollision() {
        let collided = false;

        if (this.position.x - this.radius <= 0) {
          this.position.x = this.radius;
          this.velocity.x *= -1;
          collided = true;
        } else if (this.position.x + this.radius >= canvas.width) {
          this.position.x = canvas.width - this.radius;
          this.velocity.x *= -1;
          collided = true;
        }

        if (this.position.y - this.radius <= 0) {
          this.position.y = this.radius;
          this.velocity.y *= -1;
          collided = true;
        } else if (this.position.y + this.radius >= canvas.height) {
          this.position.y = canvas.height - this.radius;
          this.velocity.y *= -1;
          collided = true;
        }

        if (collided && !this.shrink) {
          this.startShrinking();
        }
      }

      startShrinking() {
        this.shrink = true;
        this.shrinkStartTime = Date.now();
      }

      applyMouseRepulsion() {
        if (mouse.x !== null && mouse.y !== null) {
          const dx = this.position.x - mouse.x;
          const dy = this.position.y - mouse.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const maxDistance = 100; // Influence radius
          if (distance < maxDistance && distance > 0) {
            const force = (maxDistance - distance) / maxDistance;
            const repulsion = new Vector(dx / distance, dy / distance);
            repulsion.multiply(force * 0.5);
            this.velocity.add(repulsion);
          }
        }
      }

      resolveCollision(other) {
        const delta = other.position.clone();
        delta.subtract(this.position);
        const distance = delta.magnitude();

        if (distance === 0) return;

        // Normal vector
        const normal = delta.clone();
        normal.divide(distance);

        // Relative velocity
        const relativeVelocity = this.velocity.clone();
        relativeVelocity.subtract(other.velocity);

        // Velocity along the normal
        const velAlongNormal = relativeVelocity.dot(normal);

        // Do not resolve if velocities are separating
        if (velAlongNormal > 0) return;

        // Calculate impulse scalar
        const restitution = 1; // Elastic collision
        const impulseScalar = -(1 + restitution) * velAlongNormal / (1 / this.mass + 1 / other.mass);

        // Apply impulse
        const impulse = normal.clone();
        impulse.multiply(impulseScalar);
        this.velocity.add(impulse.clone().divide(this.mass));
        other.velocity.subtract(impulse.clone().divide(other.mass));

        // Prevent overlapping
        const minimumDistance = this.radius + other.radius;
        const overlap = minimumDistance - distance;
        if (overlap > 0) {
          const correction = normal.clone();
          correction.multiply(overlap / 2);
          this.position.subtract(correction);
          other.position.add(correction);
        }
      }

      shrinkBubble() {
        const elapsed = Date.now() - this.shrinkStartTime;
        const shrinkDuration = 6000; // 6 seconds
        const shrinkRatio = 1 - elapsed / shrinkDuration;

        if (shrinkRatio > 0) {
          this.size = this.originalSize * shrinkRatio;
          this.radius = this.size / 2;
          this.opacity = shrinkRatio * 0.8;
          // Slow down the bubble's speed as it shrinks
          this.velocity.multiply(0.99);
        } else {
          this.destroy();
        }
      }

      destroy() {
        const index = bubbles.indexOf(this);
        if (index > -1) {
          bubbles.splice(index, 1);
        }
      }

      draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color.replace('0.6', this.opacity.toFixed(2)).replace('0.5', this.opacity.toFixed(2)).replace('0.7', this.opacity.toFixed(2));
        ctx.fill();
      }
    }

    // Initialize Bubbles
    const bubbles = [];
    const bubbleCount = 50; // Increased bubble count for more interaction

    for (let i = 0; i < bubbleCount; i++) {
      bubbles.push(new Bubble());
    }

    // Animation Loop
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Reset Grid
      for (let key in grid) {
        grid[key] = [];
      }

      // Update and Draw Bubbles
      bubbles.forEach(bubble => {
        bubble.update();

        // Handle shrinking
        if (bubble.shrink) {
          bubble.shrinkBubble();
        }

        // Draw Bubble
        bubble.draw(ctx);
      });

      // Collision Detection using Spatial Grid
      bubbles.forEach(bubble => {
        const key = getGridKey(bubble.position.x, bubble.position.y);
        const [col, row] = key.split(',').map(Number);
        const neighboringKeys = [
          `${col},${row}`,
          `${col + 1},${row}`,
          `${col - 1},${row}`,
          `${col},${row + 1}`,
          `${col},${row - 1}`,
          `${col + 1},${row + 1}`,
          `${col - 1},${row - 1}`,
          `${col + 1},${row - 1}`,
          `${col - 1},${row + 1}`,
        ];

        neighboringKeys.forEach(k => {
          if (grid[k]) {
            grid[k].forEach(other => {
              if (other !== bubble) {
                bubble.resolveCollision(other);
              }
            });
          }
        });
      });

      // Maintain Bubble Count
      if (bubbles.length < bubbleCount) {
        bubbles.push(new Bubble());
      }

      requestAnimationFrame(animate);
    }

    animate();

    // User Controls
    const dragSlider = document.getElementById('dragSlider');
    const accSlider = document.getElementById('accSlider');
    const dragValue = document.getElementById('dragValue');
    const accValue = document.getElementById('accValue');

    dragSlider.addEventListener('input', function() {
      const value = parseFloat(this.value);
      dragValue.textContent = value.toFixed(3);
      bubbles.forEach(bubble => {
        bubble.drag = value;
      });
    });

    accSlider.addEventListener('input', function() {
      const value = parseFloat(this.value);
      accValue.textContent = value.toFixed(3);
      bubbles.forEach(bubble => {
        bubble.acceleration.y = value;
      });
    }
    );
  </script>
</body>
</html>
